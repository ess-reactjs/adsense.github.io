import{r as v,bj as V}from"./index-W2AL0DnC.js";const p={},m=e=>{v.useEffect(()=>{const t=p[e];t&&setTimeout(()=>{window.scrollTo(0,t)},50);const n=V(()=>{p[e]=window.scrollY},200);return window.addEventListener("scroll",n),()=>{window.removeEventListener("scroll",n)}},[e])},B=m;var E=new Map,g=new WeakMap,A=0,x=void 0;function M(e){return e?(g.has(e)||(A+=1,g.set(e,A.toString())),g.get(e)):"0"}function O(e){return Object.keys(e).sort().filter(t=>e[t]!==void 0).map(t=>`${t}_${t==="root"?M(e.root):e[t]}`).toString()}function _(e){const t=O(e);let n=E.get(t);if(!n){const c=new Map;let u;const o=new IntersectionObserver(s=>{s.forEach(r=>{var i;const l=r.isIntersecting&&u.some(f=>r.intersectionRatio>=f);e.trackVisibility&&typeof r.isVisible>"u"&&(r.isVisible=l),(i=c.get(r.target))==null||i.forEach(f=>{f(l,r)})})},e);u=o.thresholds||(Array.isArray(e.threshold)?e.threshold:[e.threshold||0]),n={id:t,observer:o,elements:c},E.set(t,n)}return n}function $(e,t,n={},c=x){if(typeof window.IntersectionObserver>"u"&&c!==void 0){const i=e.getBoundingClientRect();return t(c,{isIntersecting:c,target:e,intersectionRatio:typeof n.threshold=="number"?n.threshold:0,time:0,boundingClientRect:i,intersectionRect:i,rootBounds:i}),()=>{}}const{id:u,observer:o,elements:s}=_(n),r=s.get(e)||[];return s.has(e)||s.set(e,r),r.push(t),o.observe(e),function(){r.splice(r.indexOf(t),1),r.length===0&&(s.delete(e),o.unobserve(e)),s.size===0&&(o.disconnect(),E.delete(u))}}function C({threshold:e,delay:t,trackVisibility:n,rootMargin:c,root:u,triggerOnce:o,skip:s,initialInView:r,fallbackInView:i,onChange:l}={}){var f;const[b,P]=v.useState(null),w=v.useRef(),[h,I]=v.useState({inView:!!r,entry:void 0});w.current=l,v.useEffect(()=>{if(s||!b)return;let a;return a=$(b,(T,S)=>{I({inView:T,entry:S}),w.current&&w.current(T,S),S.isIntersecting&&o&&a&&(a(),a=void 0)},{root:u,rootMargin:c,threshold:e,trackVisibility:n,delay:t},i),()=>{a&&a()}},[Array.isArray(e)?e.toString():e,b,u,c,o,s,n,i,t]);const R=(f=h.entry)==null?void 0:f.target,y=v.useRef();!b&&R&&!o&&!s&&y.current!==R&&(y.current=R,I({inView:!!r,entry:void 0}));const d=[P,h.inView,h.entry];return d.ref=d[0],d.inView=d[1],d.entry=d[2],d}export{B as a,C as u};
